<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ø­Ù„ Ø¯Ù…Ø¬ Ø§Ù„Ø­ÙŠÙˆØ§Ù†Ø§Øª 
 </title>
<style>
/* CSS Variables for Theme Switching */
:root {
  /* Light Theme (Default) */
  --bg-gradient: linear-gradient(135deg, #e0f2fe 0%, #f3e8ff 100%);
  --container-bg: white;
  --text-primary: #1f2937;
  --text-secondary: #6b7280;
  --text-muted: #9ca3af;
  --panel-bg: #eff6ff;
  --board-bg: #d1d5db;
  --cell-empty: #e5e7eb;
  --shadow: 0 4px 6px rgba(0,0,0,.1);
  --shadow-light: 0 4px 6px rgba(0,0,0,.05);
  --border-color: #e5e7eb;
  --btn-text: white;
  --eval-normal: white;
  --eval-normal-text: #374151;
  --stats-bg: #f9fafb;
  --performance-bg: #fef3c7;
  --performance-text: #92400e;
}

[data-theme="dark"] {
  --bg-gradient: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
  --container-bg: #1f2937;
  --text-primary: #f9fafb;
  --text-secondary: #d1d5db;
  --text-muted: #9ca3af;
  --panel-bg: #374151;
  --board-bg: #4b5563;
  --cell-empty: #374151;
  --shadow: 0 4px 6px rgba(0,0,0,.3);
  --shadow-light: 0 4px 6px rgba(0,0,0,.2);
  --border-color: #4b5563;
  --btn-text: #f9fafb;
  --eval-normal: #4b5563;
  --eval-normal-text: #f9fafb;
  --stats-bg: #374151;
  --performance-bg: #78350f;
  --performance-text: #fef3c7;
}

/* Base Styles */
*{margin:0;padding:0;box-sizing:border-box}
body{
  font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
  background: var(--bg-gradient);
  min-height:100vh;
  padding:20px;
  transition: background 0.3s ease;
}
.container{max-width:800px;margin:0 auto}
.header{text-align:center;margin-bottom:20px}
.header h1{color:var(--text-primary);font-size:2.2em;margin-bottom:6px}
.header p{color:var(--text-secondary)}
.game-container{
  background: var(--container-bg);
  border-radius:12px;
  padding:20px;
  box-shadow: var(--shadow);
  margin-bottom:20px;
  transition: all 0.3s ease;
}
.score-row{display:flex;justify-content:space-between;margin-bottom:10px}
.score{font-size:1.1em;font-weight:bold;color:var(--text-primary)}
.moves{color:var(--text-secondary)}
.evaluation-panel{
  background:var(--panel-bg);
  border-radius:8px;
  padding:12px;
  margin-bottom:12px;
  transition: all 0.3s ease;
}
.evaluation-title{font-weight:600;color:var(--text-primary);margin-bottom:8px;font-size:.9em}
.evaluation-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:8px}
.eval-item{
  padding:8px;
  border-radius:6px;
  display:flex;
  justify-content:space-between;
  align-items:center;
  font-size:.85em;
  transition: all 0.3s ease;
}
.eval-disabled{background:#e5e7eb;color:var(--text-muted)}
.eval-chosen{background:#10b981;color:white;font-weight:bold}
.eval-best{background:#3b82f6;color:white;font-weight:600}
.eval-normal{
  background:var(--eval-normal);
  color:var(--eval-normal-text);
}
.board{
  display:grid;
  grid-template-columns:repeat(4,1fr);
  gap:8px;
  background:var(--board-bg);
  padding:12px;
  border-radius:8px;
  margin-bottom:12px;
  transition: all 0.3s ease;
}
.cell{
  aspect-ratio:1;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:1.4em;
  font-weight:bold;
  border-radius:6px;
  cursor:pointer;
  transition:all .15s;
}
.cell:hover{transform:scale(1.03)}
.cell-0{background:var(--cell-empty)}
.cell-1{background:#dbeafe;color:#1e40af}
.cell-2{background:#bfdbfe;color:#1e40af}
.cell-3{background:#93c5fd;color:#1e3a8a}
.cell-4{background:#fed7aa;color:#9a3412}
.cell-5{background:#fdba74;color:#9a3412}
.cell-6{background:#fecaca;color:#991b1b}
.cell-7{background:#fca5a5;color:#991b1b}
.cell-8{background:#fde047;color:#854d0e}
.cell-9{background:#facc15;color:#854d0e}
.cell-10{background:#86efac;color:#14532d}
.cell-11{background:#c084fc;color:#581c87}
.controls{display:flex;flex-direction:column;gap:12px}
.button-row{display:flex;gap:10px;justify-content:center}
button{
  padding:10px 18px;
  border:none;
  border-radius:8px;
  font-weight:600;
  cursor:pointer;
  transition:all .15s;
  font-size:.95em;
  color: var(--btn-text);
}
button:disabled{opacity:.5;cursor:not-allowed}
.btn-green{background:#10b981}
.btn-green:hover:not(:disabled){background:#059669}
.btn-red{background:#ef4444}
.btn-red:hover:not(:disabled){background:#dc2626}
.btn-blue{background:#3b82f6}
.btn-blue:hover:not(:disabled){background:#2563eb}
.btn-orange{background:#f97316}
.btn-orange:hover:not(:disabled){background:#ea580c}
.btn-gray{background:#6b7280}
.btn-gray:hover:not(:disabled){background:#4b5563}
.btn-theme {
  background: var(--container-bg);
  color: var(--text-primary);
  border: 2px solid var(--border-color);
}
.btn-theme:hover {
  background: var(--panel-bg);
}
.slider-row{display:flex;align-items:center;justify-content:center;gap:10px}
.slider-row label{font-weight:600;color:var(--text-primary);font-size:.9em}
.slider-row input{width:150px}
.slider-row span{color:var(--text-secondary);font-size:.9em}
.tile-selector{display:flex;align-items:center;justify-content:center;gap:10px;flex-wrap:wrap}
.tile-selector label{font-weight:600;color:var(--text-primary);font-size:.9em}
.tile-buttons{display:flex;gap:5px;flex-wrap:wrap}
.tile-btn{
  width:40px;
  height:40px;
  padding:0;
  font-size:.9em;
  border:2px solid transparent;
  color: var(--btn-text);
}
.tile-btn.selected{border-color:#3b82f6;transform:scale(1.08)}
.status{
  text-align:center;
  min-height:50px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:600;
}
.status-setup{color:#3b82f6}
.status-thinking{color:#3b82f6}
.status-waiting{color:#10b981}
.status-move{color:var(--text-secondary)}
.status-gameover{color:#ef4444;font-size:1.1em}
.info-box{
  background: var(--container-bg);
  border-radius:12px;
  padding:18px;
  box-shadow: var(--shadow-light);
  transition: all 0.3s ease;
}
.info-box h3{color:var(--text-primary);margin-bottom:10px}
.info-box p{color:var(--text-secondary);margin-bottom:8px;font-size:.9em;line-height:1.5}
.spinner{
  display:inline-block;
  width:14px;
  height:14px;
  border:2px solid #3b82f6;
  border-top-color:transparent;
  border-radius:50%;
  animation:spin .6s linear infinite
}
@keyframes spin{to{transform:rotate(360deg)}}
.hidden{display:none}
.control-row{display:flex;gap:10px;align-items:center;justify-content:center;flex-wrap:wrap}
.small{font-size:0.85em;color:var(--text-secondary)}

/* ØªØ­Ø³ÙŠÙ†Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© */
.stats-panel {
  background:var(--stats-bg);
  border-radius:8px;
  padding:12px;
  margin-bottom:12px;
  display:grid;
  grid-template-columns:repeat(3,1fr);
  gap:10px;
  transition: all 0.3s ease;
}
.stat-item {
  text-align:center;
}
.stat-value {
  font-size:1.2em;
  font-weight:bold;
  color:var(--text-primary);
}
.stat-label {
  font-size:0.8em;
  color:var(--text-secondary);
}
.high-score {
  color:#f97316;
}
.progress-container {
  margin-top:8px;
}
.progress-bar {
  height:6px;
  background:var(--cell-empty);
  border-radius:3px;
  overflow:hidden;
}
.progress-fill {
  height:100%;
  background:#10b981;
  transition:width 0.3s ease;
}
.performance-info {
  background:var(--performance-bg);
  border-radius:6px;
  padding:8px 12px;
  margin-top:8px;
  font-size:0.8em;
  color:var(--performance-text);
}
.keyboard-hint {
  font-size:0.75em;
  color:var(--text-secondary);
  margin-top:4px;
  text-align:center;
}

/* Theme Toggle Switch */
.theme-toggle {
  position: absolute;
  top: 20px;
  right: 20px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.theme-switch {
  position: relative;
  display: inline-block;
  width: 60px;
  height: 34px;
}

.theme-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #4b5563;
  transition: .4s;
  border-radius: 34px;
}

.slider:before {
  position: absolute;
  content: "";
  height: 26px;
  width: 26px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  transition: .4s;
  border-radius: 50%;
}

input:checked + .slider {
  background-color: #3b82f6;
}

input:checked + .slider:before {
  transform: translateX(26px);
}

.theme-label {
  color: var(--text-primary);
  font-weight: 600;
  font-size: 0.9em;
}

/* Dark mode specific adjustments */
[data-theme="dark"] select,
[data-theme="dark"] input[type="number"] {
  background: var(--panel-bg);
  color: var(--text-primary);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 4px 8px;
}

[data-theme="dark"] .eval-disabled {
  background: #374151;
  color: #6b7280;
}
</style>
</head>
<body>
<div class="container">
  <!-- Theme Toggle -->
  <div class="theme-toggle">
    <span class="theme-label">ğŸŒ™</span>
    <label class="theme-switch">
      <input type="checkbox" id="themeToggle">
      <span class="slider"></span>
    </label>
    <span class="theme-label">â˜€ï¸</span>
  </div>

  <div class="header">
    <h1>AI Solver (Light/Dark Mode)</h1>
    <p>Enhanced AI with theme switching â€” Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù…Ø¹ ÙˆØ¶Ø¹ Ø§Ù„Ù„ÙŠÙ„.</p>
  </div>

  <div class="game-container">
    <div class="score-row">
      <div class="score">Score: <span id="score">0</span></div>
      <div class="moves">Moves: <span id="moves">0</span></div>
    </div>

    <!-- Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª -->
    <div class="stats-panel">
      <div class="stat-item">
        <div class="stat-value" id="maxTile">0</div>
        <div class="stat-label">Max Tile</div>
      </div>
      <div class="stat-item">
        <div class="stat-value" id="emptyCells">16</div>
        <div class="stat-label">Empty Cells</div>
      </div>
      <div class="stat-item">
        <div class="stat-value high-score" id="highScore">0</div>
        <div class="stat-label">High Score</div>
      </div>
    </div>

    <div id="evaluation" class="evaluation-panel hidden">
      <div class="evaluation-title">AI Move Evaluation:</div>
      <div class="evaluation-grid" id="evalGrid"></div>
      <div style="text-align:center;margin-top:8px;font-size:.85em;color:var(--text-primary);">
        <span id="chosenMove"></span>
      </div>
      <!-- Ù…Ø¤Ø´Ø± Ø§Ù„Ø£Ø¯Ø§Ø¡ -->
      <div class="performance-info hidden" id="performanceInfo">
        <span class="spinner"></span> <span id="thinkingTime">Calculating...</span>
      </div>
    </div>

    <div class="board" id="board"></div>

    <div class="controls">
      <div id="setupControls">
        <div class="button-row">
          <button class="btn-green" onclick="startSolving()">â–¶ Start AI Solver</button>
          <button class="btn-blue" onclick="generateRandomBoard()">ğŸ² Random Board</button>
        </div>
        <p style="text-align:center;color:var(--text-secondary);font-size:.85em;margin-top:6px;">Place at least one tile to start</p>
        <p class="keyboard-hint">Tip: Use arrow keys to test moves manually in setup mode</p>
      </div>

      <div id="solverControls" class="hidden">
        <div class="control-row">
          <div class="button-row">
            <button id="playBtn" class="btn-green" onclick="togglePlay()">â–¶ Play</button>
            <button class="btn-blue" onclick="stepMove()" id="stepBtn">âš¡ Step</button>
            <button class="btn-orange" onclick="backToSetup()">âœ Edit Board</button>
            <button class="btn-gray" onclick="restartGame()">ğŸ”„ Restart</button>
          </div>
        </div>

        <div class="control-row">
          <label class="small">Algorithm:</label>
          <select id="algoSelect" onchange="updateSettings()">
            <option value="expectimax">Expectimax (recommended)</option>
            <option value="minimax">Minimax (adversarial)</option>
          </select>

          <label class="small">Depth:</label>
          <input type="range" id="depthSlider" min="1" max="6" value="3" oninput="updateSettings(this.value)">
          <span id="depthValue" class="small">3</span>

          <label class="small">P(tile=1):</label>
          <input type="number" id="p1" min="0" max="1" step="0.05" value="0.9" oninput="updateSettings()">
        </div>

        <!-- Ø´Ø±ÙŠØ· Ø§Ù„ØªÙ‚Ø¯Ù… -->
        <div class="progress-container">
          <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width:0%"></div>
          </div>
        </div>

      </div>

      <div class="button-row">
        <button class="btn-gray" onclick="resetGame()">â†» Clear Board</button>
        <button class="btn-theme" onclick="toggleThemeManual()">ğŸ¨ Toggle Theme</button>
      </div>

      <div class="slider-row">
        <label>Speed:</label>
        <input type="range" id="speedSlider" min="100" max="2000" value="500" oninput="updateSpeed(this.value)">
        <span id="speedValue">500ms</span>
      </div>

      <div class="tile-selector">
        <label id="tileSelectorLabel">Place tile:</label>
        <div class="tile-buttons" id="tileButtons"></div>
      </div>

      <div class="status" id="status">
        <span class="status-setup">ğŸ¨ Setup Mode: Click tiles to place/remove values</span>
      </div>
    </div>
  </div>

  <div class="info-box">
    <h3>What's New - Dark Mode</h3>
    <p>Ø£Ø¶ÙØª ÙˆØ¶Ø¹ Ø§Ù„Ù„ÙŠÙ„ (Dark Mode) Ù…Ø¹ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:</p>
    <ul>
      <li>ØªØ¨Ø¯ÙŠÙ„ Ø³Ù„Ø³ Ø¨ÙŠÙ† Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„ÙØ§ØªØ­ ÙˆØ§Ù„Ø¯Ø§ÙƒÙ†</li>
      <li>ØªØµÙ…ÙŠÙ… Ù…ØªÙƒØ§Ù…Ù„ Ù„Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø¯Ø§ÙƒÙ† Ù…Ø¹ Ø£Ù„ÙˆØ§Ù† Ù…Ø±ÙŠØ­Ø© Ù„Ù„Ø¹ÙŠÙ†</li>
      <li>Ø­ÙØ¸ ØªÙØ¶ÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ localStorage</li>
      <li>Ø²Ø± ÙŠØ¯ÙˆÙŠ Ù„Ù„ØªØ¨Ø¯ÙŠÙ„ Ø¨ÙŠÙ† Ø§Ù„ÙˆØ¶Ø¹ÙŠÙ†</li>
      <li>ØªØ¹Ø¯ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ù„ØªØªÙ†Ø§Ø³Ø¨ Ù…Ø¹ ÙƒÙ„Ø§ Ø§Ù„ÙˆØ¶Ø¹ÙŠÙ†</li>
    </ul>
    <p class="small">Ø¬Ø±Ø¨ Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø¨ÙŠÙ† Ø§Ù„ÙˆØ¶Ø¹ÙŠÙ† Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø²Ø± Ø£Ùˆ Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ!</p>
  </div>
</div>

<script>
/* === Game state === */
let board = Array.from({length:4},()=>Array(4).fill(0));
let score = 0, moves = 0;
let highScore = localStorage.getItem('highScore') || 0;
let selectedValue = 1;
let setupMode = true, isPlaying = false, gameOver = false;
let waitingForTile = false;
let pendingBoard = null, pendingScore = 0, lastMove = '';
let moveEvaluations = {};
let speed = 500, playInterval = null;
let startTime = 0;

/* === AI settings & cache === */
let aiAlgo = 'expectimax';
let aiDepth = 3;
let prob1 = 0.9;
const cache = new Map();

/* === Theme Management === */
let currentTheme = localStorage.getItem('theme') || 'light';

function initTheme() {
  document.documentElement.setAttribute('data-theme', currentTheme);
  document.getElementById('themeToggle').checked = currentTheme === 'dark';
}

function toggleTheme() {
  currentTheme = currentTheme === 'light' ? 'dark' : 'light';
  document.documentElement.setAttribute('data-theme', currentTheme);
  localStorage.setItem('theme', currentTheme);
}

function toggleThemeManual() {
  toggleTheme();
  // Update the toggle switch
  document.getElementById('themeToggle').checked = currentTheme === 'dark';
}

/* === Init === */
function init(){
  initTheme();
  createTileButtons();
  renderBoard();
  updateDisplay();
  updateStats();
  document.addEventListener('keydown', handleKeyPress);
  
  // Add event listener for theme toggle
  document.getElementById('themeToggle').addEventListener('change', toggleTheme);
}

function createTileButtons(){
  const container = document.getElementById('tileButtons');
  container.innerHTML = '';
  for(let i=1;i<=11;i++){
    const btn = document.createElement('button');
    btn.className = 'tile-btn cell-' + i + (i===1 ? ' selected' : '');
    btn.textContent = i;
    btn.onclick = ()=> selectTile(i);
    container.appendChild(btn);
  }
}

function selectTile(v){
  selectedValue = v;
  document.querySelectorAll('.tile-btn').forEach((b,idx)=>{
    b.classList.toggle('selected', idx+1 === v);
  });
}

/* === Rendering === */
function renderBoard(){
  const boardEl = document.getElementById('board');
  boardEl.innerHTML = '';
  const displayBoard = waitingForTile ? pendingBoard : board;
  for(let i=0;i<4;i++){
    for(let j=0;j<4;j++){
      const cell = document.createElement('div');
      const value = displayBoard[i][j];
      cell.className = 'cell cell-' + value;
      cell.textContent = value !== 0 ? value : '';
      cell.onclick = ()=> handleCellClick(i,j);
      boardEl.appendChild(cell);
    }
  }
}

/* === Click handlers === */
function handleCellClick(r,c){
  if(setupMode){
    board[r][c] = (board[r][c] === selectedValue) ? 0 : selectedValue;
    renderBoard();
    updateStats();
  } else if(waitingForTile && pendingBoard[r][c] === 0){
    placeTile(r,c);
  }
}

function placeTile(r,c){
  board = pendingBoard.map(row=>row.slice());
  board[r][c] = selectedValue;
  score += pendingScore;
  if(score > highScore) {
    highScore = score;
    localStorage.setItem('highScore', highScore);
  }
  waitingForTile = false;
  pendingBoard = null;
  pendingScore = 0;
  lastMove = '';
  if(isGameOver(board)){ gameOver = true; isPlaying = false; clearInterval(playInterval); }
  renderBoard();
  updateDisplay();
  updateStats();
}

/* === Controls === */
function startSolving(){
  const hasAny = board.some(row => row.some(v => v!==0));
  if(!hasAny) return;
  setupMode = false;
  document.getElementById('setupControls').classList.add('hidden');
  document.getElementById('solverControls').classList.remove('hidden');
  updateDisplay();
}

function backToSetup(){
  setupMode = true;
  isPlaying = false;
  gameOver = false;
  waitingForTile = false;
  pendingBoard = null;
  pendingScore = 0;
  lastMove = '';
  moveEvaluations = {};
  clearInterval(playInterval);
  document.getElementById('setupControls').classList.remove('hidden');
  document.getElementById('solverControls').classList.add('hidden');
  document.getElementById('evaluation').classList.add('hidden');
  updateDisplay();
}

function resetGame(){
  board = Array.from({length:4},()=>Array(4).fill(0));
  score = 0; moves = 0; gameOver=false; isPlaying=false; waitingForTile=false;
  pendingBoard = null; pendingScore = 0; lastMove=''; moveEvaluations={};
  cache.clear();
  clearInterval(playInterval);
  if(!setupMode) backToSetup();
  renderBoard(); 
  updateDisplay();
  updateStats();
}

function restartGame(){
  score = 0; moves = 0; gameOver=false; isPlaying=false; waitingForTile=false;
  pendingBoard = null; pendingScore = 0; lastMove=''; moveEvaluations={};
  cache.clear();
  clearInterval(playInterval);
  updateDisplay();
  updateStats();
}

function togglePlay(){
  isPlaying = !isPlaying;
  if(isPlaying) playInterval = setInterval(stepMove, speed);
  else clearInterval(playInterval);
  updateDisplay();
}

function updateSpeed(val){
  speed = parseInt(val,10);
  document.getElementById('speedValue').textContent = speed + 'ms';
  if(isPlaying){
    clearInterval(playInterval);
    playInterval = setInterval(stepMove, speed);
  }
}

function updateSettings(val){
  aiAlgo = document.getElementById('algoSelect').value;
  aiDepth = parseInt(document.getElementById('depthSlider').value,10);
  document.getElementById('depthValue').textContent = aiDepth;
  prob1 = parseFloat(document.getElementById('p1').value) || 0.9;
  cache.clear();
}

/* === Generate random board === */
function generateRandomBoard(){
  resetGame();
  const numTiles = Math.floor(Math.random() * 3) + 2;
  for(let i=0; i<numTiles; i++){
    let placed = false;
    while(!placed){
      const r = Math.floor(Math.random() * 4);
      const c = Math.floor(Math.random() * 4);
      if(board[r][c] === 0){
        board[r][c] = Math.random() < 0.9 ? 1 : 2;
        placed = true;
      }
    }
  }
  renderBoard();
  updateStats();
}

/* === Step / AI === */
async function stepMove(){
  if(gameOver || waitingForTile) return;
  updateDisplay('thinking');
  startTime = performance.now();
  
  await new Promise(r=>setTimeout(r,80));
  const bestMove = getBestMove();
  
  const endTime = performance.now();
  const thinkTime = endTime - startTime;
  
  if(bestMove){
    const result = bestMove.func(board);
    if(result.moved){
      pendingBoard = result.board.map(r=>r.slice());
      pendingScore = result.score;
      waitingForTile = true;
      lastMove = bestMove.name;
      moves++;
      
      const emptyCells = pendingBoard.flat().filter(c => c === 0).length;
      const progress = ((16 - emptyCells) / 16) * 100;
      document.getElementById('progressFill').style.width = progress + '%';
      
      document.getElementById('performanceInfo').classList.remove('hidden');
      document.getElementById('thinkingTime').textContent = `AI thought for ${thinkTime.toFixed(0)}ms`;
    } else {
      gameOver = true; isPlaying=false; clearInterval(playInterval);
    }
  } else {
    gameOver = true; isPlaying=false; clearInterval(playInterval);
  }
  renderBoard();
  updateDisplay();
  updateStats();
}

/* === AI: choose best move using selected algorithm === */
function getBestMove(){
  const movesList = [
    {func: moveLeft, name: 'LEFT'},
    {func: moveRight, name: 'RIGHT'},
    {func: moveUp, name: 'UP'},
    {func: moveDown, name: 'DOWN'}
  ];
  let best = null, bestScore = -Infinity;
  moveEvaluations = {};
  for(const m of movesList){
    const res = m.func(board);
    if(res.moved){
      let evalScore;
      if(aiAlgo === 'minimax') evalScore = minimax(res.board, aiDepth, false);
      else evalScore = expectimax(res.board, aiDepth-1);
      moveEvaluations[m.name] = evalScore;
      if(evalScore > bestScore){
        bestScore = evalScore;
        best = m;
      }
    } else {
      moveEvaluations[m.name] = null;
    }
  }
  return best;
}

/* === Minimax === */
function minimax(node, depth, maximizing){
  const key = keyFor(node, depth, maximizing, 'minimax');
  if(cache.has(key)) return cache.get(key);
  if(depth === 0 || isGameOver(node)) return evaluateBoard(node);
  if(maximizing){
    let maxEval = -Infinity;
    const moves = [moveLeft, moveRight, moveUp, moveDown];
    for(const mv of moves){
      const res = mv(node);
      if(res.moved){
        maxEval = Math.max(maxEval, minimax(res.board, depth-1, false));
      }
    }
    const out = (maxEval === -Infinity) ? evaluateBoard(node) : maxEval;
    cache.set(key,out);
    return out;
  } else {
    const empty = [];
    for(let i=0;i<4;i++) for(let j=0;j<4;j++) if(node[i][j]===0) empty.push([i,j]);
    if(empty.length===0) return evaluateBoard(node);
    let minEval = Infinity;
    for(const [r,c] of empty){
      for(const val of [1,2]){
        const nb = node.map(row=>row.slice());
        nb[r][c] = val;
        minEval = Math.min(minEval, minimax(nb, depth-1, true));
      }
    }
    const out = (minEval === Infinity) ? evaluateBoard(node) : minEval;
    cache.set(key,out);
    return out;
  }
}

/* === Expectimax === */
function expectimax(node, depth){
  const key = keyFor(node, depth, true, 'expectimax');
  if(cache.has(key)) return cache.get(key);
  if(depth === 0 || isGameOver(node)) return evaluateBoard(node);
  let maxEval = -Infinity;
  const moves = [moveLeft, moveRight, moveUp, moveDown];
  for(const mv of moves){
    const res = mv(node);
    if(res.moved){
      const val = expectChance(res.board, depth-1);
      maxEval = Math.max(maxEval, val);
    }
  }
  const out = (maxEval === -Infinity) ? evaluateBoard(node) : maxEval;
  cache.set(key,out);
  return out;
}

function expectChance(node, depth){
  const empty = [];
  for(let i=0;i<4;i++) for(let j=0;j<4;j++) if(node[i][j]===0) empty.push([i,j]);
  if(empty.length===0) return evaluateBoard(node);
  if(depth === 0) return evaluateBoard(node);
  let total = 0;
  for(const [r,c] of empty){
    const nb1 = node.map(row=>row.slice()); nb1[r][c] = 1;
    const nb2 = node.map(row=>row.slice()); nb2[r][c] = 2;
    const v1 = expectimax(nb1, depth-1);
    const v2 = expectimax(nb2, depth-1);
    total += (prob1 * v1 + (1-prob1) * v2);
  }
  return total / empty.length;
}

/* === Key for caching === */
function keyFor(boardState, depth, flag, tag){
  const rows = boardState.map(r=>r.join('')).join('|');
  return rows + ':' + depth + ':' + (flag?1:0) + ':' + tag;
}

/* === Board evaluation === */
function evaluateBoard(b){
  let empty=0, maxTile=0;
  for(let i=0;i<4;i++) for(let j=0;j<4;j++){
    if(b[i][j]===0) empty++;
    else maxTile = Math.max(maxTile, b[i][j]);
  }
  let monoScore = 0;
  for(let i=0;i<4;i++){
    for(let j=0;j<3;j++){
      if(b[i][j] >= b[i][j+1]) monoScore++;
      if(b[j][i] >= b[j+1][i]) monoScore++;
    }
  }
  let smooth = 0;
  const dirs = [[0,1],[1,0]];
  for(let i=0;i<4;i++){
    for(let j=0;j<4;j++){
      if(b[i][j]===0) continue;
      for(const [dr,dc] of dirs){
        const ni=i+dr, nj=j+dc;
        if(ni<4 && nj<4 && b[ni][nj]!==0){
          smooth += Math.abs(b[i][j] - b[ni][nj]);
        }
      }
    }
  }
  let mergePotential = 0;
  for(let i=0;i<4;i++){
    for(let j=0;j<3;j++){
      if(b[i][j] !==0 && b[i][j] === b[i][j+1]) mergePotential++;
      if(b[j][i] !==0 && b[j][i] === b[j+1][i]) mergePotential++;
    }
  }
  let corner = 0; const corners=[[0,0],[0,3],[3,0],[3,3]];
  for(const [r,c] of corners) if(b[r][c]===maxTile){ corner = maxTile; break; }

  const w_empty = 150;
  const w_max = 80;
  const w_mono = 12;
  const w_smooth = 10;
  const w_merge = 200;
  const w_corner = 220;

  const value = (w_empty * empty)
              + (w_max * maxTile)
              + (w_mono * monoScore)
              - (w_smooth * smooth)
              + (w_merge * mergePotential)
              + (w_corner * corner);
  return value;
}

/* === Game over check === */
function isGameOver(bd){
  for(let i=0;i<4;i++) for(let j=0;j<4;j++) if(bd[i][j]===0) return false;
  const moves = [moveLeft, moveRight, moveUp, moveDown];
  for(const m of moves) if(m(bd).moved) return false;
  return true;
}

/* === Moves === */
function moveLeft(boardIn){
  const newB = boardIn.map(row => row.slice());
  let totalScore = 0, moved=false;
  for(let i=0;i<4;i++){
    const original = newB[i].slice();
    let arr = newB[i].filter(v=>v!==0);
    while(arr.length<4) arr.push(0);
    for(let k=0;k<3;k++){
      if(arr[k] !== 0 && arr[k] === arr[k+1] && arr[k] < 11){
        arr[k] = arr[k] + 1;
        arr[k+1] = 0;
        totalScore += arr[k];
      }
    }
    arr = arr.filter(v=>v!==0);
    while(arr.length<4) arr.push(0);
    newB[i] = arr;
    if(JSON.stringify(original) !== JSON.stringify(newB[i])) moved = true;
  }
  return {board: newB, score: totalScore, moved};
}

function moveRight(boardIn){
  const reversed = boardIn.map(r => r.slice().reverse());
  const res = moveLeft(reversed);
  const final = res.board.map(r => r.slice().reverse());
  return { board: final, score: res.score, moved: res.moved };
}

function transpose(matrix){
  const t = Array.from({length:4},()=>Array(4).fill(0));
  for(let i=0;i<4;i++) for(let j=0;j<4;j++) t[i][j] = matrix[j][i];
  return t;
}

function moveUp(boardIn){
  const t = transpose(boardIn);
  const res = moveLeft(t);
  const final = transpose(res.board);
  return { board: final, score: res.score, moved: res.moved };
}

function moveDown(boardIn){
  const t = transpose(boardIn);
  const reversed = t.map(r => r.slice().reverse());
  const res = moveLeft(reversed);
  const unreversed = res.board.map(r => r.slice().reverse());
  const final = transpose(unreversed);
  return { board: final, score: res.score, moved: res.moved };
}

/* === Display / evaluations UI === */
function updateDisplay(state=null){
  document.getElementById('score').textContent = score;
  document.getElementById('moves').textContent = moves;
  const playBtn = document.getElementById('playBtn');
  const stepBtn = document.getElementById('stepBtn');
  const statusEl = document.getElementById('status');
  const evalPanel = document.getElementById('evaluation');

  if(setupMode){
    statusEl.innerHTML = '<span class="status-setup">ğŸ¨ Setup Mode: Click tiles to place/remove values</span>';
    evalPanel.classList.add('hidden');
  } else {
    if(state === 'thinking'){
      statusEl.innerHTML = '<span class="status-thinking"><span class="spinner"></span> AI thinking...</span>';
    } else if(waitingForTile){
      statusEl.innerHTML = '<span class="status-waiting">Select a tile value above, then click an empty cell! (pending +' + pendingScore + ')</span>';
    } else if(gameOver){
      statusEl.innerHTML = '<span class="status-gameover">Game Over! Final Score: ' + score + '</span>';
    } else if(lastMove){
      statusEl.innerHTML = '<span class="status-move">Last move: <strong>' + lastMove + '</strong></span>';
    }
    if(Object.keys(moveEvaluations).length > 0){
      evalPanel.classList.remove('hidden');
      renderEvaluations();
    } else {
      evalPanel.classList.add('hidden');
    }
  }

  if(playBtn){
    playBtn.textContent = isPlaying ? 'â¸ Pause' : 'â–¶ Play';
    playBtn.className = isPlaying ? 'btn-red' : 'btn-green';
    playBtn.disabled = gameOver || waitingForTile;
  }
  if(stepBtn){
    stepBtn.disabled = gameOver || isPlaying || waitingForTile;
  }
}

function updateStats(){
  let maxTile = 0;
  let emptyCells = 0;
  for(let i=0;i<4;i++){
    for(let j=0;j<4;j++){
      if(board[i][j] > maxTile) maxTile = board[i][j];
      if(board[i][j] === 0) emptyCells++;
    }
  }
  
  document.getElementById('maxTile').textContent = maxTile;
  document.getElementById('emptyCells').textContent = emptyCells;
  document.getElementById('highScore').textContent = highScore;
}

function renderEvaluations(){
  const grid = document.getElementById('evalGrid');
  const chosenEl = document.getElementById('chosenMove');
  grid.innerHTML = '';
  chosenEl.innerHTML = '';
  const directions = ['LEFT','RIGHT','UP','DOWN'];
  const scores = Object.values(moveEvaluations).filter(s => s !== null && s !== undefined);
  const maxScore = scores.length ? Math.max(...scores) : null;

  directions.forEach(dir=>{
    const evalScore = moveEvaluations.hasOwnProperty(dir) ? moveEvaluations[dir] : null;
    const div = document.createElement('div');
    div.className = 'eval-item ';
    if(evalScore === null){
      div.className += 'eval-disabled';
      div.innerHTML = `<span>${dir}</span><span>âœ—</span>`;
    } else {
      if(dir === lastMove) div.className += 'eval-chosen';
      else if(maxScore !== null && Math.abs(evalScore - maxScore) < 1e-6) div.className += 'eval-best';
      else div.className += 'eval-normal';
      div.innerHTML = `<span>${dir}</span><span>${Math.round(evalScore)}</span>`;
    }
    grid.appendChild(div);
  });

  if(lastMove){
    chosenEl.innerHTML = '<strong style="color:#10b981;">Chosen (executed): ' + lastMove + '</strong>';
  }
}

/* === Keyboard controls === */
function handleKeyPress(e){
  if(setupMode){
    let moveFunc = null;
    switch(e.key){
      case 'ArrowLeft': moveFunc = moveLeft; break;
      case 'ArrowRight': moveFunc = moveRight; break;
      case 'ArrowUp': moveFunc = moveUp; break;
      case 'ArrowDown': moveFunc = moveDown; break;
    }
    
    if(moveFunc){
      e.preventDefault();
      const result = moveFunc(board);
      if(result.moved){
        board = result.board;
        score += result.score;
        moves++;
        renderBoard();
        updateStats();
      }
    }
  }
}

/* === Start === */
init();
</script>
</body>
</html>
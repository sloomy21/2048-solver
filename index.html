<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>SALMAN - AI Solver (Fixed)</title>
<style>
/* (kept your original styling - unchanged for brevity) */
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:linear-gradient(135deg,#e0f2fe 0%,#f3e8ff 100%);min-height:100vh;padding:20px}
.container{max-width:600px;margin:0 auto}
.header{text-align:center;margin-bottom:30px}
.header h1{color:#1f2937;font-size:2.5em;margin-bottom:10px}
.header p{color:#6b7280}
.game-container{background:white;border-radius:12px;padding:30px;box-shadow:0 4px 6px rgba(0,0,0,.1);margin-bottom:20px}
.score-row{display:flex;justify-content:space-between;margin-bottom:20px}
.score{font-size:1.2em;font-weight:bold;color:#374151}
.moves{color:#6b7280}
.evaluation-panel{background:#eff6ff;border-radius:8px;padding:15px;margin-bottom:20px}
.evaluation-title{font-weight:600;color:#374151;margin-bottom:10px;font-size:.9em}
.evaluation-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.eval-item{padding:10px;border-radius:6px;display:flex;justify-content:space-between;align-items:center;font-size:.9em}
.eval-disabled{background:#e5e7eb;color:#9ca3af}
.eval-chosen{background:#10b981;color:white;font-weight:bold}
.eval-best{background:#3b82f6;color:white;font-weight:600}
.eval-normal{background:white;color:#374151}
.board{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;background:#d1d5db;padding:12px;border-radius:8px;margin-bottom:20px}
.cell{aspect-ratio:1;display:flex;align-items:center;justify-content:center;font-size:1.5em;font-weight:bold;border-radius:6px;cursor:pointer;transition:all .2s}
.cell:hover{transform:scale(1.05)}
.cell-0{background:#e5e7eb}
.cell-1{background:#dbeafe;color:#1e40af}
.cell-2{background:#bfdbfe;color:#1e40af}
.cell-3{background:#93c5fd;color:#1e3a8a}
.cell-4{background:#fed7aa;color:#9a3412}
.cell-5{background:#fdba74;color:#9a3412}
.cell-6{background:#fecaca;color:#991b1b}
.cell-7{background:#fca5a5;color:#991b1b}
.cell-8{background:#fde047;color:#854d0e}
.cell-9{background:#facc15;color:#854d0e}
.cell-10{background:#86efac;color:#14532d}
.cell-11{background:#c084fc;color:#581c87}
.controls{display:flex;flex-direction:column;gap:15px}
.button-row{display:flex;gap:10px;justify-content:center}
button{padding:12px 24px;border:none;border-radius:8px;font-weight:600;cursor:pointer;transition:all .2s;font-size:1em}
button:disabled{opacity:.5;cursor:not-allowed}
.btn-green{background:#10b981;color:white}
.btn-green:hover:not(:disabled){background:#059669}
.btn-red{background:#ef4444;color:white}
.btn-red:hover:not(:disabled){background:#dc2626}
.btn-blue{background:#3b82f6;color:white}
.btn-blue:hover:not(:disabled){background:#2563eb}
.btn-orange{background:#f97316;color:white}
.btn-orange:hover:not(:disabled){background:#ea580c}
.btn-gray{background:#6b7280;color:white}
.btn-gray:hover:not(:disabled){background:#4b5563}
.slider-row{display:flex;align-items:center;justify-content:center;gap:15px}
.slider-row label{font-weight:600;color:#374151;font-size:.9em}
.slider-row input{width:150px}
.slider-row span{color:#6b7280;font-size:.9em}
.tile-selector{display:flex;align-items:center;justify-content:center;gap:10px;flex-wrap:wrap}
.tile-selector label{font-weight:600;color:#374151;font-size:.9em}
.tile-buttons{display:flex;gap:5px;flex-wrap:wrap}
.tile-btn{width:40px;height:40px;padding:0;font-size:.9em;border:2px solid transparent}
.tile-btn.selected{border-color:#3b82f6;transform:scale(1.1)}
.status{text-align:center;min-height:50px;display:flex;align-items:center;justify-content:center;font-weight:600}
.status-setup{color:#3b82f6}
.status-thinking{color:#3b82f6}
.status-waiting{color:#10b981}
.status-move{color:#6b7280}
.status-gameover{color:#ef4444;font-size:1.2em}
.info-box{background:white;border-radius:12px;padding:30px;box-shadow:0 4px 6px rgba(0,0,0,.1)}
.info-box h3{color:#1f2937;margin-bottom:15px}
.info-box p{color:#6b7280;margin-bottom:10px;font-size:.9em;line-height:1.6}
.spinner{display:inline-block;width:16px;height:16px;border:2px solid #3b82f6;border-top-color:transparent;border-radius:50%;animation:spin .6s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}
.hidden{display:none}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>Ø­Ù„ Ø­Ø¯Ø« Ø¯Ù…Ø¬ Ø§Ù„Ø­ÙŠÙˆØ§Ù†Ø§Øª</h1>
    <p>ØªØ­Øª ÙˆØµÙ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬</p>
  </div>

  <div class="game-container">
    <div class="score-row">
      <div class="score">Score: <span id="score">0</span></div>
      <div class="moves">Moves: <span id="moves">0</span></div>
    </div>

    <div id="evaluation" class="evaluation-panel hidden">
      <div class="evaluation-title">AI Move Evaluation:</div>
      <div class="evaluation-grid" id="evalGrid"></div>
      <div style="text-align:center;margin-top:10px;font-size:.85em;color:#374151;">
        <span id="chosenMove"></span>
      </div>
    </div>

    <div class="board" id="board"></div>

    <div class="controls">
      <div id="setupControls">
        <div class="button-row">
          <button class="btn-green" onclick="startSolving()">â–¶ Start AI Solver</button>
        </div>
        <p style="text-align:center;color:#6b7280;font-size:.85em;margin-top:5px;" dir="rtl">Ø­Ø· ÙˆØ­Ø¯Ø© Ø¹Ø§Ù„Ø§Ù‚Ù„ Ø¹Ø´Ø§Ù† ÙŠØ¨Ø¯Ø§ :)</p>
      </div>

      <div id="solverControls" class="hidden">
        <div class="button-row">
          <button id="playBtn" class="btn-green" onclick="togglePlay()">â–¶ Play</button>
          <button class="btn-blue" onclick="stepMove()" id="stepBtn">âš¡ Step</button>
          <button class="btn-orange" onclick="backToSetup()">âœ Edit Board</button>
        </div>
      </div>

      <div class="button-row">
        <button class="btn-gray" onclick="resetGame()">â†» Clear Board</button>
      </div>

      <div class="slider-row">
        <label>Speed:</label>
        <input type="range" id="speedSlider" min="100" max="2000" value="500" oninput="updateSpeed(this.value)">
        <span id="speedValue">500ms</span>
      </div>

      <div class="tile-selector">
        <label id="tileSelectorLabel" dir="rtl">Ø§Ø®ØªØ± Ø§Ù„Ù‚ÙŠÙ…Ø©:</label>
        <div class="tile-buttons" id="tileButtons"></div>
      </div>

      <div class="status" id="status">
        <span class="status-setup">ğŸ¨ Setup Mode: Click tiles to place/remove values</span>
      </div>
    </div>
  </div>

  <div class="info-box" dir="rtl">
    <h3>Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø§Ø³ØªØ¹Ù…Ø§Ù„ </h3>
    <p><strong>Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© :</strong> Ø§Ø®ØªØ± Ø§Ù„Ø§Ø±Ù‚Ø§Ù… Ø­Ø³Ø¨ Ù…Ø§Ù‡ÙŠ Ø·Ø§Ù„Ø¹Ø© Ù„Ùƒ Ø¨Ø§Ù„Ø¹Ø¨Ø© </p>
    <p><strong>Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ :</strong> ÙÙŠ Ø­Ø§Ù„ ÙˆØ¯Ùƒ ØªØºÙŠØ± Ø§Ù„Ø§Ø±Ù‚Ø§Ù…ØŒ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø±Ù‚Ù… Ù„ØªØºÙŠÙŠØ± Ø§Ù„Ù‚ÙŠÙ…Ø©</p>
    <p><strong>ÙˆØ¶Ø¹ Ø§Ù„Ø­Ù„ :</strong> Ø§Ø¶ØºØ· "Start AI Solver" Ù„ÙŠÙ‚ÙˆÙ… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø¨Ø­Ù„ ØªÙƒÙˆÙŠÙ† Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ</p>
    <p><strong>Ù‚ÙˆØ§Ù†ÙŠÙ† Ø§Ù„Ø¯Ù…Ø¬ :</strong> 1+1=2, 2+2=3, 3+3=4... Ø§Ù„Ù‰ Ø§Ù† ØªÙˆØµÙ„ 11</p>
    <p><strong>Ø§Ù„ØªØ­ÙƒÙ…:</strong> Ø¨Ø¹Ø¯ ÙƒÙ„ Ø­Ø±ÙƒØ© Ù„Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠØŒ Ø§Ø®ØªØ± Ø£ÙŠ Ù‚ÙŠÙ…Ø© Ø­ÙŠÙˆØ§Ù† (1-11) Ù„ÙˆØ¶Ø¹Ù‡Ø§</p>
  </div>
</div>

<footer>
    <p style="text-align:center;color:#6b7280;font-size:.85em;margin-top:20px;">&copy; 2025 SALMAN QTL 172</p>
</footer>

<script>
/* === Game state === */
let board = Array.from({length:4},()=>Array(4).fill(0));
let score = 0, moves = 0;
let selectedValue = 1;
let setupMode = true, isPlaying = false, gameOver = false;
let waitingForTile = false;
let pendingBoard = null, pendingScore = 0, lastMove = '';
let moveEvaluations = {};
let speed = 500, playInterval = null;

/* === Init === */
function init(){
  createTileButtons();
  renderBoard();
  updateDisplay();
}
function createTileButtons(){
  const container = document.getElementById('tileButtons');
  container.innerHTML = '';
  for(let i=1;i<=11;i++){
    const btn = document.createElement('button');
    btn.className = 'tile-btn cell-' + i + (i===1 ? ' selected' : '');
    btn.textContent = i;
    btn.onclick = ()=> selectTile(i);
    container.appendChild(btn);
  }
}
function selectTile(v){
  selectedValue = v;
  document.querySelectorAll('.tile-btn').forEach((b,idx)=>{
    b.classList.toggle('selected', idx+1 === v);
  });
}

/* === Rendering === */
function renderBoard(){
  const boardEl = document.getElementById('board');
  boardEl.innerHTML = '';
  const displayBoard = waitingForTile ? pendingBoard : board;
  for(let i=0;i<4;i++){
    for(let j=0;j<4;j++){
      const cell = document.createElement('div');
      const value = displayBoard[i][j];
      cell.className = 'cell cell-' + value;
      cell.textContent = value !== 0 ? value : '';
      cell.onclick = ()=> handleCellClick(i,j);
      boardEl.appendChild(cell);
    }
  }
}

/* === Click handlers === */
function handleCellClick(r,c){
  if(setupMode){
    board[r][c] = (board[r][c] === selectedValue) ? 0 : selectedValue;
    renderBoard();
  } else if(waitingForTile && pendingBoard[r][c] === 0){
    placeTile(r,c);
  }
}

function placeTile(r,c){
  // commit pending board then place selected
  board = pendingBoard.map(row=>row.slice());
  board[r][c] = selectedValue;
  score += pendingScore;
  waitingForTile = false;
  pendingBoard = null;
  pendingScore = 0;
  lastMove = '';
  if(isGameOver(board)){ gameOver = true; isPlaying = false; clearInterval(playInterval); }
  renderBoard();
  updateDisplay();
}

/* === Controls === */
function startSolving(){
  const hasAny = board.some(row => row.some(v => v!==0));
  if(!hasAny) return;
  setupMode = false;
  document.getElementById('setupControls').classList.add('hidden');
  document.getElementById('solverControls').classList.remove('hidden');
  updateDisplay();
}

function backToSetup(){
  setupMode = true;
  isPlaying = false;
  gameOver = false;
  waitingForTile = false;
  pendingBoard = null;
  pendingScore = 0;
  lastMove = '';
  moveEvaluations = {};
  clearInterval(playInterval);
  document.getElementById('setupControls').classList.remove('hidden');
  document.getElementById('solverControls').classList.add('hidden');
  document.getElementById('evaluation').classList.add('hidden');
  updateDisplay();
}

function resetGame(){
  board = Array.from({length:4},()=>Array(4).fill(0));
  score = 0; moves = 0; gameOver=false; isPlaying=false; waitingForTile=false;
  pendingBoard = null; pendingScore = 0; lastMove=''; moveEvaluations={};
  clearInterval(playInterval);
  if(!setupMode) backToSetup();
  renderBoard(); updateDisplay();
}

function togglePlay(){
  isPlaying = !isPlaying;
  if(isPlaying) playInterval = setInterval(stepMove, speed);
  else clearInterval(playInterval);
  updateDisplay();
}
function updateSpeed(val){
  speed = parseInt(val,10);
  document.getElementById('speedValue').textContent = speed + 'ms';
  if(isPlaying){
    clearInterval(playInterval);
    playInterval = setInterval(stepMove, speed);
  }
}

/* === Step / AI === */
async function stepMove(){
  if(gameOver || waitingForTile) return;
  updateDisplay('thinking');
  await new Promise(r=>setTimeout(r,100));
  const bestMove = getBestMove();
  if(bestMove){
    const result = bestMove.func(board);
    if(result.moved){
      pendingBoard = result.board.map(r=>r.slice());
      pendingScore = result.score;
      waitingForTile = true;
      lastMove = bestMove.name;
      moves++;
    } else {
      // no valid move produced
      gameOver = true; isPlaying=false; clearInterval(playInterval);
    }
  } else {
    gameOver = true; isPlaying=false; clearInterval(playInterval);
  }
  renderBoard();
  updateDisplay();
}

/* === AI: choose best move using minimax === */
function getBestMove(){
  const movesList = [
    {func: moveLeft, name: 'LEFT'},
    {func: moveRight, name: 'RIGHT'},
    {func: moveUp, name: 'UP'},
    {func: moveDown, name: 'DOWN'}
  ];
  let best = null, bestScore = -Infinity;
  moveEvaluations = {};
  for(const m of movesList){
    const res = m.func(board);
    if(res.moved){
      // evaluate resulting board with minimax depth 3
      const evalScore = minimax(res.board, 3, false);
      moveEvaluations[m.name] = evalScore;
      if(evalScore > bestScore){
        bestScore = evalScore;
        best = m;
      }
    } else {
      moveEvaluations[m.name] = null;
    }
  }
  return best;
}

/* === Minimax === */
function minimax(node, depth, maximizing){
  if(depth === 0 || isGameOver(node)) return evaluateBoard(node);
  if(maximizing){
    let maxEval = -Infinity;
    const moves = [moveLeft, moveRight, moveUp, moveDown];
    for(const mv of moves){
      const res = mv(node);
      if(res.moved){
        maxEval = Math.max(maxEval, minimax(res.board, depth-1, false));
      }
    }
    return maxEval === -Infinity ? evaluateBoard(node) : maxEval;
  } else {
    // chance node: simulate adding 1 or 2 in empty cells (adversarial: choose worst)
    const empty = [];
    for(let i=0;i<4;i++) for(let j=0;j<4;j++) if(node[i][j]===0) empty.push([i,j]);
    if(empty.length===0) return evaluateBoard(node);
    let minEval = Infinity;
    for(const [r,c] of empty){
      for(const val of [1,2]){
        const nb = node.map(row=>row.slice());
        nb[r][c] = val;
        minEval = Math.min(minEval, minimax(nb, depth-1, true));
      }
    }
    return minEval === Infinity ? evaluateBoard(node) : minEval;
  }
}

/* === Board evaluation === */
function evaluateBoard(b){
  let empty=0, maxTile=0;
  for(let i=0;i<4;i++) for(let j=0;j<4;j++){
    if(b[i][j]===0) empty++;
    else maxTile = Math.max(maxTile, b[i][j]);
  }
  // monotonicity-ish
  let mono=0;
  for(let i=0;i<4;i++){
    for(let j=0;j<3;j++){
      if(b[i][j] >= b[i][j+1]) mono++;
      if(b[j][i] >= b[j+1][i]) mono++;
    }
  }
  // corner bonus
  let corner=0, corners=[[0,0],[0,3],[3,0],[3,3]];
  for(const [r,c] of corners) if(b[r][c]===maxTile){ corner = maxTile; break; }
  return empty*100 + mono*10 + corner;
}

/* === Game over check === */
function isGameOver(bd){
  for(let i=0;i<4;i++) for(let j=0;j<4;j++) if(bd[i][j]===0) return false;
  const moves = [moveLeft, moveRight, moveUp, moveDown];
  for(const m of moves) if(m(bd).moved) return false;
  return true;
}

/* === Moves (pure: return new board, score, moved) === */
function moveLeft(boardIn){
  const newB = boardIn.map(row => row.slice());
  let totalScore = 0, moved=false;
  for(let i=0;i<4;i++){
    const original = newB[i].slice();
    let arr = newB[i].filter(v=>v!==0);
    while(arr.length<4) arr.push(0);
    // combine
    for(let k=0;k<3;k++){
      if(arr[k] !== 0 && arr[k] === arr[k+1] && arr[k] < 11){
        arr[k] = arr[k] + 1;
        arr[k+1] = 0;
        totalScore += arr[k];
      }
    }
    // slide again
    arr = arr.filter(v=>v!==0);
    while(arr.length<4) arr.push(0);
    newB[i] = arr;
    if(JSON.stringify(original) !== JSON.stringify(newB[i])) moved = true;
  }
  return {board: newB, score: totalScore, moved};
}

function moveRight(boardIn){
  // reverse each row, moveLeft, then reverse back
  const reversed = boardIn.map(r => r.slice().reverse());
  const res = moveLeft(reversed);
  const final = res.board.map(r => r.slice().reverse());
  return { board: final, score: res.score, moved: res.moved };
}

function transpose(matrix){
  const t = Array.from({length:4},()=>Array(4).fill(0));
  for(let i=0;i<4;i++) for(let j=0;j<4;j++) t[i][j] = matrix[j][i];
  return t;
}

function moveUp(boardIn){
  const t = transpose(boardIn);
  const res = moveLeft(t);
  const final = transpose(res.board);
  return { board: final, score: res.score, moved: res.moved };
}

function moveDown(boardIn){
  const t = transpose(boardIn);
  const reversed = t.map(r => r.slice().reverse());
  const res = moveLeft(reversed);
  const unreversed = res.board.map(r => r.slice().reverse());
  const final = transpose(unreversed);
  return { board: final, score: res.score, moved: res.moved };
}

/* === Display / evaluations UI === */
function updateDisplay(state=null){
  document.getElementById('score').textContent = score;
  document.getElementById('moves').textContent = moves;
  const playBtn = document.getElementById('playBtn');
  const stepBtn = document.getElementById('stepBtn');
  const statusEl = document.getElementById('status');
  const evalPanel = document.getElementById('evaluation');

  if(setupMode){
    statusEl.innerHTML = '<span class="status-setup">ğŸ¨ Setup Mode: Click tiles to place/remove values</span>';
    evalPanel.classList.add('hidden');
  } else {
    if(state === 'thinking'){
      statusEl.innerHTML = '<span class="status-thinking"><span class="spinner"></span> AI thinking...</span>';
    } else if(waitingForTile){
      statusEl.innerHTML = '<span class="status-waiting">Select a tile value above, then click an empty cell! (pending +' + pendingScore + ')</span>';
    } else if(gameOver){
      statusEl.innerHTML = '<span class="status-gameover">Game Over! Final Score: ' + score + '</span>';
    } else if(lastMove){
      statusEl.innerHTML = '<span class="status-move">Last move: <strong>' + lastMove + '</strong></span>';
    }
    if(Object.keys(moveEvaluations).length > 0){
      evalPanel.classList.remove('hidden');
      renderEvaluations();
    } else {
      evalPanel.classList.add('hidden');
    }
  }

  if(playBtn){
    playBtn.textContent = isPlaying ? 'â¸ Pause' : 'â–¶ Play';
    playBtn.className = isPlaying ? 'btn-red' : 'btn-green';
    playBtn.disabled = gameOver || waitingForTile;
  }
  if(stepBtn){
    stepBtn.disabled = gameOver || isPlaying || waitingForTile;
  }
}

function renderEvaluations(){
  const grid = document.getElementById('evalGrid');
  const chosenEl = document.getElementById('chosenMove');
  grid.innerHTML = '';
  chosenEl.innerHTML = '';
  const directions = ['LEFT','RIGHT','UP','DOWN'];
  const scores = Object.values(moveEvaluations).filter(s => s !== null && s !== undefined);
  const maxScore = scores.length ? Math.max(...scores) : null;

  directions.forEach(dir=>{
    const evalScore = moveEvaluations.hasOwnProperty(dir) ? moveEvaluations[dir] : null;
    const div = document.createElement('div');
    div.className = 'eval-item ';
    if(evalScore === null){
      div.className += 'eval-disabled';
      div.innerHTML = `<span>${dir}</span><span>âœ—</span>`;
    } else {
      if(dir === lastMove) div.className += 'eval-chosen';
      else if(maxScore !== null && Math.abs(evalScore - maxScore) < 1e-6) div.className += 'eval-best';
      else div.className += 'eval-normal';
      div.innerHTML = `<span>${dir}</span><span>${Math.round(evalScore)}</span>`;
    }
    grid.appendChild(div);
  });

  if(lastMove){
    chosenEl.innerHTML = '<strong style="color:#10b981;">Chosen (executed): ' + lastMove + '</strong>';
  }
}

/* === Start === */
init();
</script>
</body>
</html>